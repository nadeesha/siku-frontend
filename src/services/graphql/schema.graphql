# Values for the AccessLevel enum
enum AccessLevel {
  admin
  readwrite
  readonly
}

input AddToUserRolesConnectionInput {
  userId: ID!
  roleId: ID!
  accessLevel: AccessLevel!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type AddToUserRolesConnectionPayload {
  # The mutated UserRoles.
  changedUserRoles: UserRoles

  # An edge containing the mutated UserRoles. Use this to update your client side cache.
  changedEdge: UserRolesEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

# An arbitrary object. AnyObject's are not type checked
#                   and are always returned in their entirety.
scalar AnyObject

# Identity object returned from the 'profile' in the response paylaod
#         of Auth0 Lock login.
input Auth0LockIdentity {
  userId: String!
  provider: String!
  connection: String!
  isSocial: Boolean!
  expiresIn: Int
}

interface Blob {
  blobUrl: String
  blobMimeType: String
}

input ChangeUserPasswordInput {
  id: ID!
  oldPassword: String!
  newPassword: String!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type ChangeUserPasswordPayload {
  # The mutated User.
  changedUser: User

  # An edge containing the mutated User. Use this to update your client side cache.
  changedEdge: UserEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

# Values for the ConnectionType enum
enum ConnectionType {
  ad
  adfs
  amazon
  dropbox
  bitbucket
  aol
  auth0_adldap
  auth0_oidc
  auth0
  baidu
  bitly
  box
  custom
  dwolla
  email
  evernote_sandbox
  evernote
  exact
  facebook
  fitbit
  flickr
  github
  google_apps
  google_oauth2
  guardian
  instagram
  ip
  linkedin
  miicard
  oauth1
  oauth2
  office365
  paypal
  pingfederate
  planningcenter
  renren
  salesforce_community
  salesforce_sandbox
  salesforce
  samlp
  sharepoint
  shopify
  sms
  soundcloud
  thecity_sandbox
  thecity
  thirtysevensignals
  twitter
  untappd
  vkontakte
  waad
  weibo
  windowslive
  wordpress
  yahoo
  yammer
  yandex
}

input CreateEventInput {
  uniqueIdentifier: String!
  type: String!
  clientMutationId: ID
}

type CreateEventPayload {
  # The mutated Event.
  changedEvent: Event

  # An edge containing the mutated Event. Use this to update your client side cache.
  changedEdge: EventEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input CreateFileInput {
  name: String
  blobFieldName: String
  clientMutationId: ID
}

type CreateFilePayload {
  # The mutated File.
  changedFile: File

  # An edge containing the mutated File. Use this to update your client side cache.
  changedEdge: FileEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input CreatePluginInput {
  publicRepoUrl: String!
  author: CreateUserInput
  authorId: ID
  name: String!
  description: String!
  clientMutationId: ID
}

input CreatePluginLinkInput {
  user: CreateUserInput
  userId: ID
  version: CreatePluginVersionInput
  versionId: ID
  clientMutationId: ID
}

type CreatePluginLinkPayload {
  # The mutated PluginLink.
  changedPluginLink: PluginLink

  # An edge containing the mutated PluginLink. Use this to update your client side cache.
  changedEdge: PluginLinkEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type CreatePluginPayload {
  # The mutated Plugin.
  changedPlugin: Plugin

  # An edge containing the mutated Plugin. Use this to update your client side cache.
  changedEdge: PluginEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input CreatePluginVersionInput {
  version: String!
  clientMutationId: ID
}

type CreatePluginVersionPayload {
  # The mutated PluginVersion.
  changedPluginVersion: PluginVersion

  # An edge containing the mutated PluginVersion. Use this to update your client side cache.
  changedEdge: PluginVersionEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input CreateRoleInput {
  name: String!
  clientMutationId: ID
}

type CreateRolePayload {
  # The mutated Role.
  changedRole: Role

  # An edge containing the mutated Role. Use this to update your client side cache.
  changedEdge: RoleEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input CreateUserInput {
  username: String!
  password: Secret!
  clientMutationId: ID
}

type CreateUserPayload {
  # The user's authentication token. Embed this under the
  #           'Authorization' header with the format 'Bearer <token>'
  #         
  token: String

  # The mutated User.
  changedUser: User

  # An edge containing the mutated User. Use this to update your client side cache.
  changedEdge: UserEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

# A range aggregation that is dedicated for date values.
#       The main difference between this aggregation and the normal range
#       aggregation is that the from and to values can be expressed in Date
#       Math expressions, and it is also possible to specify a date format
#       by which the from and to response fields will be returned. Note
#       that this aggregation includes the from value and excludes the
#       to value for each range
#       
input DateRangeInput {
  # E.G. { "from": "now-10M/M" } means '>= now minus 10 months, rounded down to the start of the month.'
  from: String

  # E.G. { "to": "now-10M/M" } means '< now minus 10 months, rounded down to the start of the month.'
  to: String
}

# The `DateTime` type represents a single point in time and is stored with
#                   millisecond precision plus a time zone specified by ISO 8601. All types come
#                   preloaded with createdAt and modifiedAt timestamps that are automatically managed
#                   for you.
scalar DateTime

input DeleteEventInput {
  id: ID!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type DeleteEventPayload {
  # The mutated Event.
  changedEvent: Event

  # An edge containing the mutated Event. Use this to update your client side cache.
  changedEdge: EventEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input DeleteFileInput {
  id: ID!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type DeleteFilePayload {
  # The mutated File.
  changedFile: File

  # An edge containing the mutated File. Use this to update your client side cache.
  changedEdge: FileEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input DeletePluginInput {
  id: ID!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input DeletePluginLinkInput {
  id: ID!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type DeletePluginLinkPayload {
  # The mutated PluginLink.
  changedPluginLink: PluginLink

  # An edge containing the mutated PluginLink. Use this to update your client side cache.
  changedEdge: PluginLinkEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type DeletePluginPayload {
  # The mutated Plugin.
  changedPlugin: Plugin

  # An edge containing the mutated Plugin. Use this to update your client side cache.
  changedEdge: PluginEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input DeletePluginVersionInput {
  id: ID!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type DeletePluginVersionPayload {
  # The mutated PluginVersion.
  changedPluginVersion: PluginVersion

  # An edge containing the mutated PluginVersion. Use this to update your client side cache.
  changedEdge: PluginVersionEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input DeleteRoleInput {
  id: ID!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type DeleteRolePayload {
  # The mutated Role.
  changedRole: Role

  # An edge containing the mutated Role. Use this to update your client side cache.
  changedEdge: RoleEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input DeleteUserInput {
  id: ID!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type DeleteUserPayload {
  # The mutated User.
  changedUser: User

  # An edge containing the mutated User. Use this to update your client side cache.
  changedEdge: UserEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

# The Event type
type Event implements Node, Timestamped {
  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set when an object is first created.
  createdAt: DateTime!
  user: UserConnection
  uniqueIdentifier: String!
  pluginVersion: PluginVersionConnection

  # A globally unique ID.
  id: ID!
  type: String!

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set whenever an object is mutated.
  modifiedAt: DateTime!
}

type EventAggregations {
  # Returns the number of objects in the connection.
  count: Int

  # The minimum value for the field
  min: EventAggregationsMin

  # The maximum value for the field
  max: EventAggregationsMax
}

type EventAggregationsMax {
  createdAt: DateTime
  modifiedAt: DateTime
  uniqueIdentifier: String
  type: String
}

type EventAggregationsMin {
  createdAt: DateTime
  modifiedAt: DateTime
  uniqueIdentifier: String
  type: String
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type EventConnection {
  # The set of edges in this page.
  edges: [EventEdge]

  # Metadata on the current page of data.
  pageInfo: PageInfo!

  # Aggregation operators for the Event type.
  aggregations: EventAggregations
}

input EventCreatedAtSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input EventCreatedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type EventEdge {
  # The node value for the edge.
  node: Event!

  # An opaque cursor pointing to an object in a connection.
  #           Used by the 'after' and 'before' pagination arguments.
  cursor: String!
}

input EventIdSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]
}

input EventIdWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # Not equal to.
  ne: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input EventModifiedAtSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input EventModifiedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

enum EventMutationEvent {
  # Subscribe to this event to be notified after every createEvent mutation.
  createEvent

  # Subscribe to this event to be notified after every updateEvent mutation.
  updateEvent

  # Subscribe to this event to be notified after every deleteEvent mutation.
  deleteEvent
}

input EventOrderByArgs {
  field: EventOrderByField
  direction: OrderByDirection
}

# Values for the EventOrderByField enum
enum EventOrderByField {
  createdAt
  uniqueIdentifier
  id
  type
  modifiedAt
}

# Subscription filter arguments for the Event type
input EventSubscriptionFilter {
  # Filter results for on the createdAt field.
  createdAt: EventCreatedAtSubscriptionFilters

  # Filter results for on the uniqueIdentifier field.
  uniqueIdentifier: EventUniqueIdentifierSubscriptionFilters

  # Filter results for on the id field.
  id: EventIdSubscriptionFilters

  # Filter results for on the type field.
  type: EventTypeSubscriptionFilters

  # Filter results for on the modifiedAt field.
  modifiedAt: EventModifiedAtSubscriptionFilters
}

# A payload wrapper for mutation operations.
type EventSubscriptionPayload {
  # The type of mutation operation that triggered this subscription.
  mutation: EventMutationEvent

  # The object that was just mutated.
  value: Event
  edge: EventEdge
}

input EventTypeSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # Not equal to.
  ne: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input EventTypeWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Not equal to.
  ne: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input EventUniqueIdentifierSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # Not equal to.
  ne: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input EventUniqueIdentifierWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Not equal to.
  ne: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# Where filter arguments for the Event type
input EventWhereArgs {
  # Filter results for on the createdAt field.
  createdAt: EventCreatedAtWhereArgs

  # Filter results for on the uniqueIdentifier field.
  uniqueIdentifier: EventUniqueIdentifierWhereArgs

  # Filter results for on the id field.
  id: EventIdWhereArgs

  # Filter results for on the type field.
  type: EventTypeWhereArgs

  # Filter results for on the modifiedAt field.
  modifiedAt: EventModifiedAtWhereArgs

  # Combine mutiple where expressions using the OR operator.
  OR: [EventWhereArgs]

  # Combine mutiple where expressions using the AND operator.
  AND: [EventWhereArgs]
}

# A Scaphold User.
type Field implements Node {
  # A global id
  id: ID!
  name: String!
  description: String
  columnName: String
  nonNull: Boolean
  unique: Boolean
  indexed: Boolean
  type: String
  ofType: String
  ofTypeNonNull: Boolean
  reverseName: String
  defaultValue: AnyObject
  isEditable: Boolean
  through: String
  position: Int
}

# The File type
type File implements Node, Timestamped, Blob {
  # The name of the File. If no name is given, the uploaded file's name will be used.
  name: String

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set whenever an object is mutated.
  modifiedAt: DateTime!

  # The mimeType of the blob asset.
  blobMimeType: String

  # A globally unique ID.
  id: ID!

  # A pre-signed url to your file.
  blobUrl: String

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set when an object is first created.
  createdAt: DateTime!
}

type FileAggregations {
  # Returns the number of objects in the connection.
  count: Int

  # The minimum value for the field
  min: FileAggregationsMin

  # The maximum value for the field
  max: FileAggregationsMax
}

type FileAggregationsMax {
  name: String
  blobMimeType: String
  blobUrl: String
  modifiedAt: DateTime
  createdAt: DateTime
}

type FileAggregationsMin {
  name: String
  blobMimeType: String
  blobUrl: String
  modifiedAt: DateTime
  createdAt: DateTime
}

input FileBlobMimeTypeSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # Not equal to.
  ne: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input FileBlobMimeTypeWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Not equal to.
  ne: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input FileBlobUrlSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # Not equal to.
  ne: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input FileBlobUrlWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Not equal to.
  ne: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type FileConnection {
  # The set of edges in this page.
  edges: [FileEdge]

  # Metadata on the current page of data.
  pageInfo: PageInfo!

  # Aggregation operators for the File type.
  aggregations: FileAggregations
}

input FileCreatedAtSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input FileCreatedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type FileEdge {
  # The node value for the edge.
  node: File!

  # An opaque cursor pointing to an object in a connection.
  #           Used by the 'after' and 'before' pagination arguments.
  cursor: String!
}

input FileIdSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]
}

input FileIdWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # Not equal to.
  ne: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input FileModifiedAtSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input FileModifiedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

enum FileMutationEvent {
  # Subscribe to this event to be notified after every createFile mutation.
  createFile

  # Subscribe to this event to be notified after every updateFile mutation.
  updateFile

  # Subscribe to this event to be notified after every deleteFile mutation.
  deleteFile
}

input FileNameSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # Not equal to.
  ne: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input FileNameWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Not equal to.
  ne: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input FileOrderByArgs {
  field: FileOrderByField
  direction: OrderByDirection
}

# Values for the FileOrderByField enum
enum FileOrderByField {
  name
  modifiedAt
  blobMimeType
  id
  blobUrl
  createdAt
}

# Subscription filter arguments for the File type
input FileSubscriptionFilter {
  # Filter results for on the name field.
  name: FileNameSubscriptionFilters

  # Filter results for on the modifiedAt field.
  modifiedAt: FileModifiedAtSubscriptionFilters

  # Filter results for on the blobMimeType field.
  blobMimeType: FileBlobMimeTypeSubscriptionFilters

  # Filter results for on the id field.
  id: FileIdSubscriptionFilters

  # Filter results for on the blobUrl field.
  blobUrl: FileBlobUrlSubscriptionFilters

  # Filter results for on the createdAt field.
  createdAt: FileCreatedAtSubscriptionFilters
}

# A payload wrapper for mutation operations.
type FileSubscriptionPayload {
  # The type of mutation operation that triggered this subscription.
  mutation: FileMutationEvent

  # The object that was just mutated.
  value: File
  edge: FileEdge
}

# Where filter arguments for the File type
input FileWhereArgs {
  # Filter results for on the name field.
  name: FileNameWhereArgs

  # Filter results for on the modifiedAt field.
  modifiedAt: FileModifiedAtWhereArgs

  # Filter results for on the blobMimeType field.
  blobMimeType: FileBlobMimeTypeWhereArgs

  # Filter results for on the id field.
  id: FileIdWhereArgs

  # Filter results for on the blobUrl field.
  blobUrl: FileBlobUrlWhereArgs

  # Filter results for on the createdAt field.
  createdAt: FileCreatedAtWhereArgs

  # Combine mutiple where expressions using the OR operator.
  OR: [FileWhereArgs]

  # Combine mutiple where expressions using the AND operator.
  AND: [FileWhereArgs]
}

type HealthStatus {
  # Returns `true` for healthy and `false` for unhealthy.
  healthy: Boolean!

  # Additional information about the health of the API.
  message: String
}

input LoginUserInput {
  username: String!
  password: String!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type LoginUserPayload {
  # The user's authentication token. Embed this under the
  #           'Authorization' header with the format 'Bearer <token>'
  #         
  token: String

  # The mutated User.
  user: User

  # An edge containing the mutated User. Use this to update your client side cache.
  changedEdge: UserEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input LoginUserWithAuth0Input {
  idToken: String!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input LoginUserWithAuth0LockInput {
  # The identity from the "profile" object of the response payload from Auth0 Lock.
  identity: Auth0LockIdentity!

  # The access token of the the social authentication connection. This should be
  #           obtained via an SDK through connections like Facebook, Twitter, or Google.
  access_token: String

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type LoginUserWithAuth0LockPayload {
  # The mutated User.
  user: User

  # An edge containing the mutated User. Use this to update your client side cache.
  changedEdge: UserEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type LoginUserWithAuth0Payload {
  # The mutated User.
  user: User

  # An edge containing the mutated User. Use this to update your client side cache.
  changedEdge: UserEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input LoginUserWithAuth0SocialInput {
  # The access token of the the social authentication connection. This should be
  #           obtained via an SDK through connections like Facebook, Twitter, or Google.
  access_token: String!

  # The social connection name (i.e. Facebook, Google, Twitter, etc...).
  connection: ConnectionType!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type LoginUserWithAuth0SocialPayload {
  # The access token of the logged in user issued
  #             from the social authentication connection.
  access_token: String

  # The id token of the logged in user issued from the
  #             social authentication connection.
  token: String

  # The type of the token.
  token_type: String

  # The mutated User.
  user: User

  # An edge containing the mutated User. Use this to update your client side cache.
  changedEdge: UserEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type MetricAggregationResult {
  value: AnyObject
  value_as_string: String
}

# A Scaphold User.
input MigrateFieldInput {
  # A global id
  id: ID
  name: String!
  description: String
  columnName: String
  nonNull: Boolean
  unique: Boolean
  indexed: Boolean
  type: String
  ofType: String
  ofTypeNonNull: Boolean
  reverseName: String
  defaultValue: AnyObject
  isEditable: Boolean
  through: String
  position: Int
}

# A scaphold type permission.
input MigratePermissionInput {
  id: ID
  scope: PermissionScopeEnum!
  userFields: [MigrateFieldInput]
  protectedFields: [MigrateFieldInput]
  roles: [MigrateRoleInput]
  create: Boolean
  read: Boolean
  update: Boolean
  delete: Boolean
  enabled: Boolean
}

# A scaphold type permission.
input MigrateRoleInput {
  id: ID!
  name: String!
}

input MigrateSchemaInput {
  id: ID!
  name: String
  description: String
  types: [MigrateTypeInput]

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type MigrateSchemaPayload {
  # The mutated Schema.
  changedSchema: Schema

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

# A Scaphold User.
input MigrateTypeInput {
  # A global id
  id: ID
  name: String!
  description: String
  kind: TypeKind!
  interfaces: [String]
  fields: [MigrateFieldInput]
  permissions: [MigratePermissionInput]
  values: [String]
  isBridge: Boolean
  position: Int
  isEditable: Boolean
  isDeletable: Boolean
  isExtendable: Boolean
}

type Mutation {
  migrateSchema(input: MigrateSchemaInput!): MigrateSchemaPayload
  loginUser(input: LoginUserInput!): LoginUserPayload
  changeUserPassword(input: ChangeUserPasswordInput!): ChangeUserPasswordPayload

  # Create objects of type File.
  createFile(input: CreateFileInput!): CreateFilePayload

  # Update objects of type File.
  updateFile(input: UpdateFileInput!): UpdateFilePayload

  # Delete objects of type File.
  deleteFile(input: DeleteFileInput!): DeleteFilePayload

  # Create objects of type PluginVersion.
  createPluginVersion(input: CreatePluginVersionInput!): CreatePluginVersionPayload

  # Update objects of type PluginVersion.
  updatePluginVersion(input: UpdatePluginVersionInput!): UpdatePluginVersionPayload

  # Delete objects of type PluginVersion.
  deletePluginVersion(input: DeletePluginVersionInput!): DeletePluginVersionPayload

  # Create objects of type User.
  createUser(input: CreateUserInput!): CreateUserPayload

  # Update objects of type User.
  updateUser(input: UpdateUserInput!): UpdateUserPayload

  # Delete objects of type User.
  deleteUser(input: DeleteUserInput!): DeleteUserPayload

  # Create objects of type Plugin.
  createPlugin(input: CreatePluginInput!): CreatePluginPayload

  # Update objects of type Plugin.
  updatePlugin(input: UpdatePluginInput!): UpdatePluginPayload

  # Delete objects of type Plugin.
  deletePlugin(input: DeletePluginInput!): DeletePluginPayload

  # Create objects of type PluginLink.
  createPluginLink(input: CreatePluginLinkInput!): CreatePluginLinkPayload

  # Update objects of type PluginLink.
  updatePluginLink(input: UpdatePluginLinkInput!): UpdatePluginLinkPayload

  # Delete objects of type PluginLink.
  deletePluginLink(input: DeletePluginLinkInput!): DeletePluginLinkPayload

  # Create objects of type Event.
  createEvent(input: CreateEventInput!): CreateEventPayload

  # Update objects of type Event.
  updateEvent(input: UpdateEventInput!): UpdateEventPayload

  # Delete objects of type Event.
  deleteEvent(input: DeleteEventInput!): DeleteEventPayload

  # Create objects of type Role.
  createRole(input: CreateRoleInput!): CreateRolePayload

  # Update objects of type Role.
  updateRole(input: UpdateRoleInput!): UpdateRolePayload

  # Delete objects of type Role.
  deleteRole(input: DeleteRoleInput!): DeleteRolePayload

  # Adds a connection between an object of type
  #     'User' and an object of type Role. You can edit
  #     the 'UserRoles' bridge type to add/remove custom fields for this connection.
  #   
  addToUserRolesConnection(input: AddToUserRolesConnectionInput!): AddToUserRolesConnectionPayload

  # Updates an existing connection between an object of type
  #     'User' and an object of type Role.
  #   
  updateUserRolesConnection(input: UpdateUserRolesConnectionInput!): UpdateUserRolesConnectionPayload

  # Removes a connection between an object of type
  #     'User' and an object of type Role.
  #   
  removeFromUserRolesConnection(input: RemoveFromUserRolesConnectionInput!): RemoveFromUserRolesConnectionPayload

  # The input object type used to log in a user with Auth0 Social
  loginUserWithAuth0Social(input: LoginUserWithAuth0SocialInput!): LoginUserWithAuth0SocialPayload

  # The input object type used to log in a user with Auth0 Lock
  loginUserWithAuth0Lock(input: LoginUserWithAuth0LockInput!): LoginUserWithAuth0LockPayload
  loginUserWithAuth0(input: LoginUserWithAuth0Input!): LoginUserWithAuth0Payload
}

type NestedResolverLogAggregation {
  doc_count: Int
  aggregations: ResolverLogAggregationSet
}

interface Node {
  id: ID!
}

# Values for the OrderByDirection enum
enum OrderByDirection {
  ASC
  DESC
}

# PageInfo must contain fields hasPreviousPage and hasNextPage,
#                 both of which return non‐null booleans.
type PageInfo {
  # hasNextPage will be false if the client is not paginating with first,
  #                     or if the client is paginating with first, and the server has determined
  #                     that the client has reached the end of the set of edges defined by their
  #                     cursors.
  hasNextPage: Boolean!

  # hasPreviousPage will be false if the client is not paginating with last,
  #                         or if the client is paginating with last, and the server has determined
  #                         that the client has reached the end of the set of edges defined by their
  #                         cursors.
  hasPreviousPage: Boolean!
}

# A scaphold type permission.
type Permission implements Node {
  id: ID!
  scope: PermissionScopeEnum!
  userFields: [Field]
  protectedFields: [Field]
  roles: [Role]
  enabled: Boolean
  create: Boolean
  read: Boolean
  update: Boolean
  delete: Boolean
  createdAt: DateTime
  modifiedAt: DateTime
}

# Values for the PermissionScopeEnum enum
enum PermissionScopeEnum {
  EVERYONE
  AUTHENTICATED
  RELATION
  ROLE
}

# The Plugin type
type Plugin implements Node, Timestamped {
  publicRepoUrl: String!
  author: User

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set when an object is first created.
  createdAt: DateTime!
  name: String!

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set whenever an object is mutated.
  modifiedAt: DateTime!

  # A globally unique ID.
  id: ID!
  description: String!
}

type PluginAggregations {
  # Returns the number of objects in the connection.
  count: Int

  # The minimum value for the field
  min: PluginAggregationsMin

  # The maximum value for the field
  max: PluginAggregationsMax
}

type PluginAggregationsMax {
  publicRepoUrl: String
  name: String
  description: String
  createdAt: DateTime
  modifiedAt: DateTime
}

type PluginAggregationsMin {
  publicRepoUrl: String
  name: String
  description: String
  createdAt: DateTime
  modifiedAt: DateTime
}

input PluginAuthorIdSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]
}

input PluginAuthorIdWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # Not equal to.
  ne: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type PluginConnection {
  # The set of edges in this page.
  edges: [PluginEdge]

  # Metadata on the current page of data.
  pageInfo: PageInfo!

  # Aggregation operators for the Plugin type.
  aggregations: PluginAggregations
}

input PluginCreatedAtSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PluginCreatedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PluginDescriptionSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # Not equal to.
  ne: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PluginDescriptionWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Not equal to.
  ne: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type PluginEdge {
  # The node value for the edge.
  node: Plugin!

  # An opaque cursor pointing to an object in a connection.
  #           Used by the 'after' and 'before' pagination arguments.
  cursor: String!
}

input PluginIdSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]
}

input PluginIdWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # Not equal to.
  ne: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# The PluginLink type
type PluginLink implements Node, Timestamped {
  # A globally unique ID.
  id: ID!

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set when an object is first created.
  createdAt: DateTime!

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set whenever an object is mutated.
  modifiedAt: DateTime!
  user: User
  version: PluginVersion
}

type PluginLinkAggregations {
  # Returns the number of objects in the connection.
  count: Int

  # The minimum value for the field
  min: PluginLinkAggregationsMin

  # The maximum value for the field
  max: PluginLinkAggregationsMax
}

type PluginLinkAggregationsMax {
  createdAt: DateTime
  modifiedAt: DateTime
}

type PluginLinkAggregationsMin {
  createdAt: DateTime
  modifiedAt: DateTime
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type PluginLinkConnection {
  # The set of edges in this page.
  edges: [PluginLinkEdge]

  # Metadata on the current page of data.
  pageInfo: PageInfo!

  # Aggregation operators for the PluginLink type.
  aggregations: PluginLinkAggregations
}

input PluginLinkCreatedAtSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PluginLinkCreatedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type PluginLinkEdge {
  # The node value for the edge.
  node: PluginLink!

  # An opaque cursor pointing to an object in a connection.
  #           Used by the 'after' and 'before' pagination arguments.
  cursor: String!
}

input PluginLinkIdSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]
}

input PluginLinkIdWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # Not equal to.
  ne: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PluginLinkModifiedAtSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PluginLinkModifiedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

enum PluginLinkMutationEvent {
  # Subscribe to this event to be notified after every createPluginLink mutation.
  createPluginLink

  # Subscribe to this event to be notified after every updatePluginLink mutation.
  updatePluginLink

  # Subscribe to this event to be notified after every deletePluginLink mutation.
  deletePluginLink
}

input PluginLinkOrderByArgs {
  field: PluginLinkOrderByField
  direction: OrderByDirection
}

# Values for the PluginLinkOrderByField enum
enum PluginLinkOrderByField {
  id
  createdAt
  modifiedAt
}

# Subscription filter arguments for the PluginLink type
input PluginLinkSubscriptionFilter {
  # Filter results for on the id field.
  id: PluginLinkIdSubscriptionFilters

  # Filter results for on the createdAt field.
  createdAt: PluginLinkCreatedAtSubscriptionFilters

  # Filter results for on the modifiedAt field.
  modifiedAt: PluginLinkModifiedAtSubscriptionFilters

  # Filter results for on the userId field.
  userId: PluginLinkUserIdSubscriptionFilters

  # Filter results for on the versionId field.
  versionId: PluginLinkVersionIdSubscriptionFilters
}

# A payload wrapper for mutation operations.
type PluginLinkSubscriptionPayload {
  # The type of mutation operation that triggered this subscription.
  mutation: PluginLinkMutationEvent

  # The object that was just mutated.
  value: PluginLink
  edge: PluginLinkEdge
}

input PluginLinkUserIdSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]
}

input PluginLinkUserIdWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # Not equal to.
  ne: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PluginLinkVersionIdSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]
}

input PluginLinkVersionIdWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # Not equal to.
  ne: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# Where filter arguments for the PluginLink type
input PluginLinkWhereArgs {
  # Filter results for on the id field.
  id: PluginLinkIdWhereArgs

  # Filter results for on the createdAt field.
  createdAt: PluginLinkCreatedAtWhereArgs

  # Filter results for on the modifiedAt field.
  modifiedAt: PluginLinkModifiedAtWhereArgs

  # Filter results based on a related object via the user connection
  user: UserWhereArgs

  # Filter results based on a related object via the version connection
  version: PluginVersionWhereArgs

  # Filter results for on the userId field.
  userId: PluginLinkUserIdWhereArgs

  # Filter results for on the versionId field.
  versionId: PluginLinkVersionIdWhereArgs

  # Combine mutiple where expressions using the OR operator.
  OR: [PluginLinkWhereArgs]

  # Combine mutiple where expressions using the AND operator.
  AND: [PluginLinkWhereArgs]
}

input PluginModifiedAtSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PluginModifiedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

enum PluginMutationEvent {
  # Subscribe to this event to be notified after every createPlugin mutation.
  createPlugin

  # Subscribe to this event to be notified after every updatePlugin mutation.
  updatePlugin

  # Subscribe to this event to be notified after every deletePlugin mutation.
  deletePlugin
}

input PluginNameSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # Not equal to.
  ne: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PluginNameWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Not equal to.
  ne: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PluginOrderByArgs {
  field: PluginOrderByField
  direction: OrderByDirection
}

# Values for the PluginOrderByField enum
enum PluginOrderByField {
  publicRepoUrl
  createdAt
  name
  modifiedAt
  id
  description
}

input PluginPublicRepoUrlSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # Not equal to.
  ne: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PluginPublicRepoUrlWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Not equal to.
  ne: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# Subscription filter arguments for the Plugin type
input PluginSubscriptionFilter {
  # Filter results for on the publicRepoUrl field.
  publicRepoUrl: PluginPublicRepoUrlSubscriptionFilters

  # Filter results for on the createdAt field.
  createdAt: PluginCreatedAtSubscriptionFilters

  # Filter results for on the name field.
  name: PluginNameSubscriptionFilters

  # Filter results for on the modifiedAt field.
  modifiedAt: PluginModifiedAtSubscriptionFilters

  # Filter results for on the id field.
  id: PluginIdSubscriptionFilters

  # Filter results for on the description field.
  description: PluginDescriptionSubscriptionFilters

  # Filter results for on the authorId field.
  authorId: PluginAuthorIdSubscriptionFilters
}

# A payload wrapper for mutation operations.
type PluginSubscriptionPayload {
  # The type of mutation operation that triggered this subscription.
  mutation: PluginMutationEvent

  # The object that was just mutated.
  value: Plugin
  edge: PluginEdge
}

# The PluginVersion type
type PluginVersion implements Node, Timestamped {
  plugin: PluginConnection

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set whenever an object is mutated.
  modifiedAt: DateTime!

  # A globally unique ID.
  id: ID!

  # The reverse field of 'version' in 1:M connection
  #             with type 'undefined'.
  links(where: PluginLinkWhereArgs, orderBy: [PluginLinkOrderByArgs], first: Int, after: String, last: Int, before: String): PluginLinkConnection

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set when an object is first created.
  createdAt: DateTime!
  version: String!
}

type PluginVersionAggregations {
  # Returns the number of objects in the connection.
  count: Int

  # The minimum value for the field
  min: PluginVersionAggregationsMin

  # The maximum value for the field
  max: PluginVersionAggregationsMax
}

type PluginVersionAggregationsMax {
  modifiedAt: DateTime
  createdAt: DateTime
  version: String
}

type PluginVersionAggregationsMin {
  modifiedAt: DateTime
  createdAt: DateTime
  version: String
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type PluginVersionConnection {
  # The set of edges in this page.
  edges: [PluginVersionEdge]

  # Metadata on the current page of data.
  pageInfo: PageInfo!

  # Aggregation operators for the PluginVersion type.
  aggregations: PluginVersionAggregations
}

input PluginVersionCreatedAtSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PluginVersionCreatedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type PluginVersionEdge {
  # The node value for the edge.
  node: PluginVersion!

  # An opaque cursor pointing to an object in a connection.
  #           Used by the 'after' and 'before' pagination arguments.
  cursor: String!
}

input PluginVersionIdSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]
}

input PluginVersionIdWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # Not equal to.
  ne: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PluginVersionModifiedAtSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PluginVersionModifiedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

enum PluginVersionMutationEvent {
  # Subscribe to this event to be notified after every createPluginVersion mutation.
  createPluginVersion

  # Subscribe to this event to be notified after every updatePluginVersion mutation.
  updatePluginVersion

  # Subscribe to this event to be notified after every deletePluginVersion mutation.
  deletePluginVersion
}

input PluginVersionOrderByArgs {
  field: PluginVersionOrderByField
  direction: OrderByDirection
}

# Values for the PluginVersionOrderByField enum
enum PluginVersionOrderByField {
  modifiedAt
  id
  createdAt
  version
}

# Subscription filter arguments for the PluginVersion type
input PluginVersionSubscriptionFilter {
  # Filter results for on the modifiedAt field.
  modifiedAt: PluginVersionModifiedAtSubscriptionFilters

  # Filter results for on the id field.
  id: PluginVersionIdSubscriptionFilters

  # Filter results for on the createdAt field.
  createdAt: PluginVersionCreatedAtSubscriptionFilters

  # Filter results for on the version field.
  version: PluginVersionVersionSubscriptionFilters
}

# A payload wrapper for mutation operations.
type PluginVersionSubscriptionPayload {
  # The type of mutation operation that triggered this subscription.
  mutation: PluginVersionMutationEvent

  # The object that was just mutated.
  value: PluginVersion
  edge: PluginVersionEdge
}

input PluginVersionVersionSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # Not equal to.
  ne: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input PluginVersionVersionWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Not equal to.
  ne: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# Where filter arguments for the PluginVersion type
input PluginVersionWhereArgs {
  # Filter results for on the modifiedAt field.
  modifiedAt: PluginVersionModifiedAtWhereArgs

  # Filter results for on the id field.
  id: PluginVersionIdWhereArgs

  # Filter results based on a related object via the links connection
  links: PluginLinkWhereArgs

  # Filter results for on the createdAt field.
  createdAt: PluginVersionCreatedAtWhereArgs

  # Filter results for on the version field.
  version: PluginVersionVersionWhereArgs

  # Combine mutiple where expressions using the OR operator.
  OR: [PluginVersionWhereArgs]

  # Combine mutiple where expressions using the AND operator.
  AND: [PluginVersionWhereArgs]
}

# Where filter arguments for the Plugin type
input PluginWhereArgs {
  # Filter results for on the publicRepoUrl field.
  publicRepoUrl: PluginPublicRepoUrlWhereArgs

  # Filter results based on a related object via the author connection
  author: UserWhereArgs

  # Filter results for on the createdAt field.
  createdAt: PluginCreatedAtWhereArgs

  # Filter results for on the name field.
  name: PluginNameWhereArgs

  # Filter results for on the modifiedAt field.
  modifiedAt: PluginModifiedAtWhereArgs

  # Filter results for on the id field.
  id: PluginIdWhereArgs

  # Filter results for on the description field.
  description: PluginDescriptionWhereArgs

  # Filter results for on the authorId field.
  authorId: PluginAuthorIdWhereArgs

  # Combine mutiple where expressions using the OR operator.
  OR: [PluginWhereArgs]

  # Combine mutiple where expressions using the AND operator.
  AND: [PluginWhereArgs]
}

type Query {
  node(id: ID!): Node

  # Get objects of type File by id.
  getFile(id: ID!): File

  # Get objects of type PluginVersion by id.
  getPluginVersion(id: ID!): PluginVersion

  # Get objects of type User by id.
  getUser(id: ID!): User

  # Get objects of type Plugin by id.
  getPlugin(id: ID!): Plugin

  # Get objects of type PluginLink by id.
  getPluginLink(id: ID!): PluginLink

  # Get objects of type Event by id.
  getEvent(id: ID!): Event

  # Get objects of type Role by id.
  getRole(id: ID!): Role
  viewer: Viewer

  # Check the health of your GraphQL API by pinging the server.
  #           It will return `true` for healthy and `false` for unhealthy.
  checkHealth: HealthStatus
  searchRequestLogs: RequestLogSearchResults
}

input RemoveFromUserRolesConnectionInput {
  userId: ID!
  roleId: ID!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type RemoveFromUserRolesConnectionPayload {
  # The mutated UserRoles.
  changedUserRoles: UserRoles

  # An edge containing the mutated UserRoles. Use this to update your client side cache.
  changedEdge: UserRolesEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

# ### RequestLog
#
#         Request Logs are backed by elasticsearch and therefore offer more powerful querying and
#         analytical capabilities. We have adapted the ElasticSearch API to better fit GraphQL, but
#         the concepts remain the same. The definitive guide is a great place to start if you are
#         new to search (https://www.elastic.co/guide/en/elasticsearch/guide/current/index.html),
#         and these docs cover the API in more detail:
#         (https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html)
type RequestLog implements Node {
  id: ID!
  username: String
  isAdmin: Boolean
  isBillable: Boolean
  start: DateTime
  duration: Int
  responseSizeBytes: Int
  requestMethod: String
  status: String
  errors: [String]
  resolvers: [ResolverLog]
  createdAt: DateTime!
}

type RequestLogAggregationBucket {
  doc_count: Int
  key: AnyObject
  key_as_string: String
  aggregations: RequestLogAggregationSet
}

type RequestLogAggregationSet {
  avg(field: RequestLogNumericField): MetricAggregationResult
  cardinality(field: RequestLogField, precision_threshhold: Int): MetricAggregationResult
  max(field: RequestLogNumericField): MetricAggregationResult
  min(field: RequestLogNumericField): MetricAggregationResult
  percentiles(field: RequestLogNumericField): MetricAggregationResult
  stats(field: RequestLogNumericField): StatsAggregationResult
  sum(field: RequestLogNumericField): MetricAggregationResult
  value_count(field: RequestLogNumericField): MetricAggregationResult
  date_range(field: RequestLogDateTimeField, format: String, ranges: [DateRangeInput]!): RequestLogBucketAggregation
  date_histogram(field: RequestLogDateTimeField, interval: String, format: String, time_zone: String, missing: String): RequestLogBucketAggregation
  terms(field: RequestLogStringField, size: Int, missing: String): RequestLogBucketAggregation
  filter(term: RequestLogTermFilter): RequestLogFilterAggregation
  resolvers: NestedResolverLogAggregation
}

type RequestLogBucketAggregation {
  buckets: [RequestLogAggregationBucket]
}

# Values for the RequestLogDateTimeField enum
enum RequestLogDateTimeField {
  createdAt
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type RequestLogEdge {
  # The node value for the edge.
  node: RequestLog!

  # An opaque cursor pointing to an object in a connection.
  #           Used by the 'after' and 'before' pagination arguments.
  cursor: String!
}

# Values for the RequestLogField enum
enum RequestLogField {
  appId
  userId
  isAdmin
  username
  isBillable
  status
  logType
  start
  createdAt
  duration
  durationHr
  responseSizeBytes
  requestMethod
  originalUrl
  errors
  resolvers
}

type RequestLogFilterAggregation {
  doc_count: Int
  aggregations: RequestLogAggregationSet
}

# Values for the RequestLogNumericField enum
enum RequestLogNumericField {
  duration
  responseSizeBytes
}

type RequestLogSearchResults {
  # Returns a set of documents satisfying the query string and pagination
  # arguments. The 'q' querystring accepts any elasticsearch query string. See
  # (https://www.elastic.co/guide/en/elasticsearch/reference/current/
  # query-dsl-query-string-query.html#query-string-syntax) for mre details.
  edges(q: String, first: Int = 50, after: String): [RequestLogEdge]

  # Run complex aggregations on your data.
  aggregations: RequestLogAggregationSet
  took: Int
}

# Values for the RequestLogStringField enum
enum RequestLogStringField {
  appId
  userId
  username
  status
  logType
  requestMethod
  originalUrl
  errors
}

input RequestLogTermFilter {
  appId: String
  userId: String
  username: String
  status: String
  logType: String
  requestMethod: String
  originalUrl: String
  errors: String
  isAdmin: Boolean
  isBillable: Boolean
  duration: Int
  responseSizeBytes: Int
}

type ResolverLog {
  parentType: String
  returnType: String
  parsedReturnType: String
  fieldName: String
  operation: String
  start: DateTime
  minDuration: Int
  maxDuration: Int
  avgDuration: Int
  totalDuration: Int
  count: Int
  path: [String]
  statuses: String
  errors: String
}

type ResolverLogAggregationBucket {
  doc_count: Int
  key: AnyObject
  key_as_string: String
  aggregations: ResolverLogAggregationSet
}

type ResolverLogAggregationSet {
  avg(field: ResolverLogNumericField): MetricAggregationResult
  cardinality(field: ResolverLogField, precision_threshhold: Int): MetricAggregationResult
  max(field: ResolverLogNumericField): MetricAggregationResult
  min(field: ResolverLogNumericField): MetricAggregationResult
  percentiles(field: ResolverLogNumericField): MetricAggregationResult
  stats(field: ResolverLogNumericField): StatsAggregationResult
  sum(field: ResolverLogNumericField): MetricAggregationResult
  value_count(field: ResolverLogNumericField): MetricAggregationResult
  date_range(field: ResolverLogDateTimeField, format: String, ranges: [DateRangeInput]!): ResolverLogBucketAggregation
  date_histogram(field: ResolverLogDateTimeField, interval: String, format: String, time_zone: String, missing: String): ResolverLogBucketAggregation
  terms(field: ResolverLogStringField, size: Int, missing: String): ResolverLogBucketAggregation
  filter(term: ResolverLogTermFilter): ResolverLogFilterAggregation
}

type ResolverLogBucketAggregation {
  buckets: [ResolverLogAggregationBucket]
}

# Values for the ResolverLogDateTimeField enum
enum ResolverLogDateTimeField {
  start
}

# Values for the ResolverLogField enum
enum ResolverLogField {
  fieldName
  operation
  start
  path
  status
  error
  totalDuration
  count
  minDuration
  maxDuration
  avgDuration
  parentType
  returnType
  parsedReturnType
}

type ResolverLogFilterAggregation {
  doc_count: Int
  aggregations: ResolverLogAggregationSet
}

# Values for the ResolverLogNumericField enum
enum ResolverLogNumericField {
  totalDuration
  count
  minDuration
  maxDuration
  avgDuration
}

# Values for the ResolverLogStringField enum
enum ResolverLogStringField {
  fieldName
  operation
  path
  status
  error
  parentType
  returnType
  parsedReturnType
}

input ResolverLogTermFilter {
  fieldName: String
  operation: String
  path: String
  status: String
  error: String
  parentType: String
  returnType: String
  parsedReturnType: String
  totalDuration: Int
  count: Int
  minDuration: Int
  maxDuration: Int
  avgDuration: Float
}

# The Role type
type Role implements Node, Timestamped {
  # A globally unique ID.
  id: ID!

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set when an object is first created.
  createdAt: DateTime!

  # The name of the role.
  name: String!

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set whenever an object is mutated.
  modifiedAt: DateTime!

  # The user`s belonging to this role
  members(where: UserWhereArgs, orderBy: [UserOrderByArgs], first: Int, after: String, last: Int, before: String): RoleMembersConnection
}

type RoleAggregations {
  # Returns the number of objects in the connection.
  count: Int

  # The minimum value for the field
  min: RoleAggregationsMin

  # The maximum value for the field
  max: RoleAggregationsMax
}

type RoleAggregationsMax {
  createdAt: DateTime
  modifiedAt: DateTime
  name: String
}

type RoleAggregationsMin {
  createdAt: DateTime
  modifiedAt: DateTime
  name: String
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type RoleConnection {
  # The set of edges in this page.
  edges: [RoleEdge]

  # Metadata on the current page of data.
  pageInfo: PageInfo!

  # Aggregation operators for the Role type.
  aggregations: RoleAggregations
}

input RoleCreatedAtSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input RoleCreatedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type RoleEdge {
  # The node value for the edge.
  node: Role!

  # An opaque cursor pointing to an object in a connection.
  #           Used by the 'after' and 'before' pagination arguments.
  cursor: String!
}

input RoleIdSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]
}

input RoleIdWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # Not equal to.
  ne: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type RoleMembersConnection {
  # The set of edges in this page.
  edges: [RoleMembersEdge]

  # Metadata on the current page of data.
  pageInfo: PageInfo!

  # Aggregation operators for the User type.
  aggregations: UserAggregations
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type RoleMembersEdge {
  # The node value for the edge.
  node: User!

  # An opaque cursor pointing to an object in a connection.
  #           Used by the 'after' and 'before' pagination arguments.
  cursor: String!

  # The access level for this user enrollment.
  accessLevel: AccessLevel!

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set whenever an object is mutated.
  modifiedAt: DateTime!

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set when an object is first created.
  createdAt: DateTime!
}

# Select objects by filtering on objects in a connection
input RoleMembersWhereArgs {
  # Filter on values on the connection edge. E.G. Get all users with readonly membership to a role.
  edge: UserRolesEdgeWhereArgs

  # Filter on values in the target type. E.G. Get all users that are a member of the Executives role
  node: UserWhereArgs
}

input RoleModifiedAtSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input RoleModifiedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

enum RoleMutationEvent {
  # Subscribe to this event to be notified after every createRole mutation.
  createRole

  # Subscribe to this event to be notified after every updateRole mutation.
  updateRole

  # Subscribe to this event to be notified after every deleteRole mutation.
  deleteRole
}

input RoleNameSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # Not equal to.
  ne: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input RoleNameWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Not equal to.
  ne: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input RoleOrderByArgs {
  field: RoleOrderByField
  direction: OrderByDirection
}

# Values for the RoleOrderByField enum
enum RoleOrderByField {
  id
  createdAt
  name
  modifiedAt
}

# Subscription filter arguments for the Role type
input RoleSubscriptionFilter {
  # Filter results for on the id field.
  id: RoleIdSubscriptionFilters

  # Filter results for on the createdAt field.
  createdAt: RoleCreatedAtSubscriptionFilters

  # Filter results for on the name field.
  name: RoleNameSubscriptionFilters

  # Filter results for on the modifiedAt field.
  modifiedAt: RoleModifiedAtSubscriptionFilters
}

# A payload wrapper for mutation operations.
type RoleSubscriptionPayload {
  # The type of mutation operation that triggered this subscription.
  mutation: RoleMutationEvent

  # The object that was just mutated.
  value: Role
  edge: RoleEdge
}

# Where filter arguments for the Role type
input RoleWhereArgs {
  # Filter results for on the id field.
  id: RoleIdWhereArgs

  # Filter results for on the createdAt field.
  createdAt: RoleCreatedAtWhereArgs

  # Filter results for on the name field.
  name: RoleNameWhereArgs

  # Filter results for on the modifiedAt field.
  modifiedAt: RoleModifiedAtWhereArgs

  # Filter results based on a related object via the members connection
  members: RoleMembersWhereArgs

  # Combine mutiple where expressions using the OR operator.
  OR: [RoleWhereArgs]

  # Combine mutiple where expressions using the AND operator.
  AND: [RoleWhereArgs]
}

# A Scaphold Schema.
type Schema implements Node {
  # A global id
  id: ID!
  name: String!
  description: String
  types: [Type]
  createdAt: DateTime
  modifiedAt: DateTime
}

#
#       The 'Secret' scalar type represents textual data, represented as UTF-8 that should not
#       be readable. The Secret type is often used to hide sensitive information such as passwords
#       and credentials.
#     
scalar Secret

type StatsAggregationResult {
  count: Int
  min: Float
  max: Float
  avg: Float
  sum: Float
}

type Subscription {
  subscribeToFile(filter: FileSubscriptionFilter, mutations: [FileMutationEvent]!): FileSubscriptionPayload
  subscribeToPluginVersion(filter: PluginVersionSubscriptionFilter, mutations: [PluginVersionMutationEvent]!): PluginVersionSubscriptionPayload
  subscribeToUser(filter: UserSubscriptionFilter, mutations: [UserMutationEvent]!): UserSubscriptionPayload
  subscribeToPlugin(filter: PluginSubscriptionFilter, mutations: [PluginMutationEvent]!): PluginSubscriptionPayload
  subscribeToPluginLink(filter: PluginLinkSubscriptionFilter, mutations: [PluginLinkMutationEvent]!): PluginLinkSubscriptionPayload
  subscribeToEvent(filter: EventSubscriptionFilter, mutations: [EventMutationEvent]!): EventSubscriptionPayload
  subscribeToRole(filter: RoleSubscriptionFilter, mutations: [RoleMutationEvent]!): RoleSubscriptionPayload
}

interface Timestamped {
  modifiedAt: DateTime!
  createdAt: DateTime!
}

# A Scaphold User.
type Type implements Node {
  # A global id
  id: ID!
  name: String!
  description: String
  kind: TypeKind
  interfaces: [String]
  fields: [Field]
  permissions: [Permission]
  values: [String]
  isBridge: Boolean
  position: Int
  isEditable: Boolean
  isDeletable: Boolean
  isExtendable: Boolean
  createdAt: DateTime
  modifiedAt: DateTime
}

# Options for types that can be built on scaphold.
enum TypeKind {
  OBJECT
  ENUM
  INTERFACE
}

input UpdateEventInput {
  uniqueIdentifier: String
  id: ID!
  type: String

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type UpdateEventPayload {
  # The mutated Event.
  changedEvent: Event

  # An edge containing the mutated Event. Use this to update your client side cache.
  changedEdge: EventEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input UpdateFileInput {
  name: String
  id: ID!
  blobFieldName: String

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type UpdateFilePayload {
  # The mutated File.
  changedFile: File

  # An edge containing the mutated File. Use this to update your client side cache.
  changedEdge: FileEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input UpdatePluginInput {
  publicRepoUrl: String
  authorId: ID
  name: String
  id: ID!
  description: String

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input UpdatePluginLinkInput {
  id: ID!
  userId: ID
  versionId: ID

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type UpdatePluginLinkPayload {
  # The mutated PluginLink.
  changedPluginLink: PluginLink

  # An edge containing the mutated PluginLink. Use this to update your client side cache.
  changedEdge: PluginLinkEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type UpdatePluginPayload {
  # The mutated Plugin.
  changedPlugin: Plugin

  # An edge containing the mutated Plugin. Use this to update your client side cache.
  changedEdge: PluginEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input UpdatePluginVersionInput {
  id: ID!
  version: String

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type UpdatePluginVersionPayload {
  # The mutated PluginVersion.
  changedPluginVersion: PluginVersion

  # An edge containing the mutated PluginVersion. Use this to update your client side cache.
  changedEdge: PluginVersionEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input UpdateRoleInput {
  id: ID!
  name: String

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type UpdateRolePayload {
  # The mutated Role.
  changedRole: Role

  # An edge containing the mutated Role. Use this to update your client side cache.
  changedEdge: RoleEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input UpdateUserInput {
  username: String
  password: Secret
  id: ID!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type UpdateUserPayload {
  # The mutated User.
  changedUser: User

  # An edge containing the mutated User. Use this to update your client side cache.
  changedEdge: UserEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

input UpdateUserRolesConnectionInput {
  userId: ID!
  roleId: ID!
  accessLevel: AccessLevel!

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

type UpdateUserRolesConnectionPayload {
  # The mutated UserRoles.
  changedUserRoles: UserRoles

  # An edge containing the mutated UserRoles. Use this to update your client side cache.
  changedEdge: UserRolesEdge

  # A view port into your application.
  viewer: Viewer

  # An opaque string used by frontend frameworks like relay to track requests and responses.
  clientMutationId: String
}

# The User type
type User implements Node, Timestamped {
  # An automatically managed timestamp that is set every time a user logs in.
  lastLogin: DateTime!

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set when an object is first created.
  createdAt: DateTime!

  # A list of roles in which this user is enrolled
  roles(where: RoleWhereArgs, orderBy: [RoleOrderByArgs], first: Int, after: String, last: Int, before: String): UserRolesConnection

  # The reverse field of 'user' in 1:M connection
  #             with type 'undefined'.
  pluginLinks(where: PluginLinkWhereArgs, orderBy: [PluginLinkOrderByArgs], first: Int, after: String, last: Int, before: String): PluginLinkConnection

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set whenever an object is mutated.
  modifiedAt: DateTime!

  # The user's username.
  username: String!

  # A globally unique ID.
  id: ID!

  # The reverse field of 'author' in 1:M connection
  #             with type 'undefined'.
  authoredPlugins(where: PluginWhereArgs, orderBy: [PluginOrderByArgs], first: Int, after: String, last: Int, before: String): PluginConnection
}

type UserAggregations {
  # Returns the number of objects in the connection.
  count: Int

  # The minimum value for the field
  min: UserAggregationsMin

  # The maximum value for the field
  max: UserAggregationsMax
}

type UserAggregationsMax {
  lastLogin: DateTime
  createdAt: DateTime
  modifiedAt: DateTime
  username: String
}

type UserAggregationsMin {
  lastLogin: DateTime
  createdAt: DateTime
  modifiedAt: DateTime
  username: String
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type UserConnection {
  # The set of edges in this page.
  edges: [UserEdge]

  # Metadata on the current page of data.
  pageInfo: PageInfo!

  # Aggregation operators for the User type.
  aggregations: UserAggregations
}

input UserCreatedAtSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input UserCreatedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type UserEdge {
  # The node value for the edge.
  node: User!

  # An opaque cursor pointing to an object in a connection.
  #           Used by the 'after' and 'before' pagination arguments.
  cursor: String!
}

input UserIdSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]
}

input UserIdWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: ID

  # Not equal to.
  ne: ID

  # A list of values to include.
  in: [ID]

  # A list of values to exclude.
  notIn: [ID]

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input UserLastLoginSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input UserLastLoginWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input UserModifiedAtSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # Not equal to.
  ne: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input UserModifiedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

enum UserMutationEvent {
  # Subscribe to this event to be notified after every loginUser mutation.
  loginUser

  # Subscribe to this event to be notified after every createUser mutation.
  createUser

  # Subscribe to this event to be notified after every updateUser mutation.
  updateUser

  # Subscribe to this event to be notified after every deleteUser mutation.
  deleteUser
}

input UserOrderByArgs {
  field: UserOrderByField
  direction: OrderByDirection
}

# Values for the UserOrderByField enum
enum UserOrderByField {
  lastLogin
  createdAt
  modifiedAt
  username
  password
  id
}

input UserPasswordSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: Secret

  # Greater than.
  gt: Secret

  # Greater than or equal to.
  gte: Secret

  # Less than.
  lt: Secret

  # Less than or equal to.
  lte: Secret

  # Not equal to.
  ne: Secret

  # A two element tuple describing a range of values.
  between: [Secret]

  # A two element tuple describing an excluded range of values.
  notBetween: [Secret]

  # A list of values to include.
  in: [Secret]

  # A list of values to exclude.
  notIn: [Secret]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input UserPasswordWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: Secret

  # Not equal to.
  ne: Secret

  # Greater than.
  gt: Secret

  # Greater than or equal to.
  gte: Secret

  # Less than.
  lt: Secret

  # Less than or equal to.
  lte: Secret

  # A two element tuple describing a range of values.
  between: [Secret]

  # A two element tuple describing an excluded range of values.
  notBetween: [Secret]

  # A list of values to include.
  in: [Secret]

  # A list of values to exclude.
  notIn: [Secret]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# The UserRoles type
type UserRoles implements Timestamped {
  # The access level for this user enrollment.
  accessLevel: AccessLevel!

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set whenever an object is mutated.
  modifiedAt: DateTime!

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set when an object is first created.
  createdAt: DateTime!
  user: User
  role: Role
}

input UserRolesAccessLevelWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: AccessLevel

  # Not equal to.
  ne: AccessLevel

  # Greater than.
  gt: AccessLevel

  # Greater than or equal to.
  gte: AccessLevel

  # Less than.
  lt: AccessLevel

  # Less than or equal to.
  lte: AccessLevel

  # A two element tuple describing a range of values.
  between: [AccessLevel]

  # A two element tuple describing an excluded range of values.
  notBetween: [AccessLevel]

  # A list of values to include.
  in: [AccessLevel]

  # A list of values to exclude.
  notIn: [AccessLevel]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type UserRolesConnection {
  # The set of edges in this page.
  edges: [UserRolesEdge]

  # Metadata on the current page of data.
  pageInfo: PageInfo!

  # Aggregation operators for the Role type.
  aggregations: RoleAggregations
}

input UserRolesCreatedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# An edge wraps a node and a cursor. Edges are returned by
#       Connection types as a standard way to paginate through connection values.
type UserRolesEdge {
  # The node value for the edge.
  node: Role!

  # An opaque cursor pointing to an object in a connection.
  #           Used by the 'after' and 'before' pagination arguments.
  cursor: String!

  # The access level for this user enrollment.
  accessLevel: AccessLevel!

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set whenever an object is mutated.
  modifiedAt: DateTime!

  # When paired with the Node interface, this is an automatically managed
  #           timestamp that is set when an object is first created.
  createdAt: DateTime!
}

# Where filter arguments for the UserRoles type
input UserRolesEdgeWhereArgs {
  # Filter results based on values in the bridge model.
  accessLevel: UserRolesAccessLevelWhereArgs

  # Filter results based on values in the bridge model.
  modifiedAt: UserRolesModifiedAtWhereArgs

  # Filter results based on values in the bridge model.
  createdAt: UserRolesCreatedAtWhereArgs
}

input UserRolesModifiedAtWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: DateTime

  # Not equal to.
  ne: DateTime

  # Greater than.
  gt: DateTime

  # Greater than or equal to.
  gte: DateTime

  # Less than.
  lt: DateTime

  # Less than or equal to.
  lte: DateTime

  # A two element tuple describing a range of values.
  between: [DateTime]

  # A two element tuple describing an excluded range of values.
  notBetween: [DateTime]

  # A list of values to include.
  in: [DateTime]

  # A list of values to exclude.
  notIn: [DateTime]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# Select objects by filtering on objects in a connection
input UserRolesWhereArgs {
  # Filter on values on the connection edge. E.G. Get all users with readonly membership to a role.
  edge: UserRolesEdgeWhereArgs

  # Filter on values in the target type. E.G. Get all users that are a member of the Executives role
  node: RoleWhereArgs
}

# Subscription filter arguments for the User type
input UserSubscriptionFilter {
  # Filter results for on the lastLogin field.
  lastLogin: UserLastLoginSubscriptionFilters

  # Filter results for on the createdAt field.
  createdAt: UserCreatedAtSubscriptionFilters

  # Filter results for on the modifiedAt field.
  modifiedAt: UserModifiedAtSubscriptionFilters

  # Filter results for on the username field.
  username: UserUsernameSubscriptionFilters

  # Filter results for on the password field.
  password: UserPasswordSubscriptionFilters

  # Filter results for on the id field.
  id: UserIdSubscriptionFilters
}

# A payload wrapper for mutation operations.
type UserSubscriptionPayload {
  # The type of mutation operation that triggered this subscription.
  mutation: UserMutationEvent

  # The object that was just mutated.
  value: User
  edge: UserEdge
}

input UserUsernameSubscriptionFilters {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # Not equal to.
  ne: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # A regular expression to match on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  matches: String

  # A regular expression to reject on. Note that unlike 'like' this uses regular expression syntax instead of SQL like syntax.
  notMatches: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

input UserUsernameWhereArgs {
  # Equal to. This takes a higher precedence than the other operators.
  eq: String

  # Not equal to.
  ne: String

  # Greater than.
  gt: String

  # Greater than or equal to.
  gte: String

  # Less than.
  lt: String

  # Less than or equal to.
  lte: String

  # A two element tuple describing a range of values.
  between: [String]

  # A two element tuple describing an excluded range of values.
  notBetween: [String]

  # A list of values to include.
  in: [String]

  # A list of values to exclude.
  notIn: [String]

  # A pattern to match for likeness.
  like: String

  # A pattern to match for likeness and exclude.
  notLike: String

  # Filters for null values. This takes precedence after 'eq' but before all other fields
  isNull: Boolean
}

# Where filter arguments for the User type
input UserWhereArgs {
  # Filter results for on the lastLogin field.
  lastLogin: UserLastLoginWhereArgs

  # Filter results for on the createdAt field.
  createdAt: UserCreatedAtWhereArgs

  # Filter results based on a related object via the roles connection
  roles: UserRolesWhereArgs

  # Filter results based on a related object via the pluginLinks connection
  pluginLinks: PluginLinkWhereArgs

  # Filter results for on the modifiedAt field.
  modifiedAt: UserModifiedAtWhereArgs

  # Filter results for on the username field.
  username: UserUsernameWhereArgs

  # Filter results for on the password field.
  password: UserPasswordWhereArgs

  # Filter results for on the id field.
  id: UserIdWhereArgs

  # Filter results based on a related object via the authoredPlugins connection
  authoredPlugins: PluginWhereArgs

  # Combine mutiple where expressions using the OR operator.
  OR: [UserWhereArgs]

  # Combine mutiple where expressions using the AND operator.
  AND: [UserWhereArgs]
}

type Viewer implements Node {
  id: ID!

  # Sift through all objects of type 'File'.
  allFiles(where: FileWhereArgs, orderBy: [FileOrderByArgs], first: Int, after: String, last: Int, before: String): FileConnection

  # Sift through all objects of type 'PluginVersion'.
  allPluginVersions(where: PluginVersionWhereArgs, orderBy: [PluginVersionOrderByArgs], first: Int, after: String, last: Int, before: String): PluginVersionConnection

  # Sift through all objects of type 'User'.
  allUsers(where: UserWhereArgs, orderBy: [UserOrderByArgs], first: Int, after: String, last: Int, before: String): UserConnection

  # Sift through all objects of type 'Plugin'.
  allPlugins(where: PluginWhereArgs, orderBy: [PluginOrderByArgs], first: Int, after: String, last: Int, before: String): PluginConnection

  # Sift through all objects of type 'PluginLink'.
  allPluginLinks(where: PluginLinkWhereArgs, orderBy: [PluginLinkOrderByArgs], first: Int, after: String, last: Int, before: String): PluginLinkConnection

  # Sift through all objects of type 'Event'.
  allEvents(where: EventWhereArgs, orderBy: [EventOrderByArgs], first: Int, after: String, last: Int, before: String): EventConnection

  # Sift through all objects of type 'Role'.
  allRoles(where: RoleWhereArgs, orderBy: [RoleOrderByArgs], first: Int, after: String, last: Int, before: String): RoleConnection

  # Returns the currently logged in user and is also the entry point for queries that leverage RELATION scoped permissions.
  user: User
}

